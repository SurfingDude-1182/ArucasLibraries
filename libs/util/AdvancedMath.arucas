class PerlinNoise { //TODO: extend Transformation
    var vector_grid = {};
    var vector_grid_2d = {};
    var dismantler;

    PerlinNoise(){
        this.dismantler = fun(vec) { return vec; }; 
    }

    PerlinNoise(dismantler){
        this.dismantler = dismantler;
    }

    fun calculatePerlinValue(pos){
        pos = this.dismantler(pos);
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(pos[0])+i;
            if(!this.vector_grid.getKeys().contains(x))
            this.vector_grid[x]={};
            for(j = 0;j<2;j++){
                y = Math.floor(pos[1])+j;
                if(!this.vector_grid[x].getKeys().contains(y))
                this.vector_grid[x][y]={};
                for(k = 0;k<2;k++){
                    z =  Math.floor(pos[2])+k;
                    if(!this.vector_grid[x][y].getKeys().contains(z)){
                        angle_1 = random(360);
                        angle_2 = random(360);
                        this.vector_grid[x][y][z] = [Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2))];
                        //this.vector_grid[x][y][z] = [random(3)-1,random(3)-1,random(3)-1)];
                    }
                    vectorList.append([x, y, z]);
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(j = 0;j<2;j++){
                for(k = 0;k<2;k++){
                    x = Math.floor(pos[0])+i;
                    y = Math.floor(pos[1])+j;
                    z = Math.floor(pos[2])+k;
                    cornerVector = this.vector_grid[x][y][z];
                    localX = pos[0]-Math.floor(pos[0])-i;
                    localY = pos[1]-Math.floor(pos[1])-j;
                    localZ = pos[2]-Math.floor(pos[2])-k;
                    dotProduct = cornerVector[0]*localX + cornerVector[1]*localY + cornerVector[2]*localZ;
                    dotProductList.append(dotProduct);
                }
            }
        }
        interpolationLevel1 = [];
        for(i=0;i<8;i=i+2){
            weight = pos[2]-Math.floor(pos[2]);
            interpolationLevel1.append(this.interpolate(dotProductList[i],dotProductList[i+1],weight));
        }
        interpolatedNumber1 = this.interpolate(interpolationLevel1[0],interpolationLevel1[1],pos[1]-Math.floor(pos[1]));
        interpolatedNumber2 = this.interpolate(interpolationLevel1[2],interpolationLevel1[3],pos[1]-Math.floor(pos[1]));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,pos[0]-Math.floor(pos[0]));
    }

    //2d noise
    fun calculatePerlinValue(input_x,input_z){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(input_x)+i;
            if(!this.vector_grid_2d.getKeys().contains(x))
            this.vector_grid_2d[x]={};
            for(k = 0;k<2;k++){
                z =  Math.floor(input_z)+k;
                if(!this.vector_grid_2d[x].getKeys().contains(z)){
                    angle_1 = random(360);
                    angle_2 = random(360);
                    //this.vector_grid[x][y][z] = [Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2))];
                    this.vector_grid_2d[x][z] = [random(3)-1,0,random(3)-1];
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(k = 0;k<2;k++){
                x = Math.floor(input_x)+i;
                y = 0;
                z = Math.floor(input_z)+k;
                cornerVector = this.vector_grid_2d[x][z];
                localX = input_x-Math.floor(input_x)-i;
                localY = 0;
                localZ = input_z-Math.floor(input_z)-k;
                dotProduct = cornerVector[0]*localX + cornerVector[2]*localZ;
                dotProductList.append(dotProduct);
            }
        }
        
        interpolatedNumber1 = this.interpolate(dotProductList[0],dotProductList[1],input_z-Math.floor(input_z));
        interpolatedNumber2 = this.interpolate(dotProductList[2],dotProductList[3],input_z-Math.floor(input_z));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,input_x-Math.floor(input_x));
    }

    fun interpolate(number1, number2, weight){
        output = number1+this.fadeFunction(weight)*(number2-number1);
        return output;
    }

    fun fadeFunction(number){
        return (6*number^5)-(15*number^4)+(10*number^3);
    }
}

class BezierCurve { //TODO: extend Transformation
    var p1;
    var p2;
    var p3;
    var p4;
    var quadratic = true;
    var coordinates;

    var dismantler = fun(vec) { return vec; }; 
    var factory = fun(x, y, z) { return [x, y, z]; };

    static fun getPoints(posList,resolution){
        quadratic = true;
        p1 = posList.get(0);
        p2 = posList.get(1);
        p3 = posList.get(2);
        coordinates = [];
        if (len(posList) == 4) {
            p4 = posList.get(3);
            quadratic = false;
        }
        for(t = 0; t < 1; t = t + resolution){
            if (this.quadratic) {
                for (t = 0; t < 1; t = t + (1/resolution)) {
                    x = (1 - t)^2 * this.p1[0] + 2 * (1 - t) * t * this.p2[0] + t^2 * this.p3[0];
                    y = (1 - t)^2 * this.p1[1] + 2 * (1 - t) * t * this.p2[1] + t^2 * this.p3[1];
                    z = (1 - t)^2 * this.p1[2] + 2 * (1 - t) * t * this.p2[2] + t^2 * this.p3[2];
                    coordinates.append([x,y,z]);
                }
            }
            else { //cubic
                for (t = 0; t < 1; t = t + (1/resolution)) {
                    x = (1 - t)^3 * this.p1[0] + 3 * (1 - t)^2 * t * this.p2[0] + 3 * (1 - t) * t^2 * this.p3[0] + t^3 * this.p4[0];
                    y = (1 - t)^3 * this.p1[1] + 3 * (1 - t)^2 * t * this.p2[1] + 3 * (1 - t) * t^2 * this.p3[1] + t^3 * this.p4[1];
                    z = (1 - t)^3 * this.p1[2] + 3 * (1 - t)^2 * t * this.p2[2] + 3 * (1 - t) * t^2 * this.p3[2] + t^3 * this.p4[2];
                    coordinates.append([x,y,z]);
                }
            }
        }
    }
     
    BezierCurve(posList) {
        this.p1 = posList.get(0);
        this.p2 = posList.get(1);
        this.p3 = posList.get(2);
        if (len(posList) == 4) {
            this.p4 = posList.get(3);
            this.quadratic = false;
        }
        this.coordinates = this.getPoints(100);
    }

    fun getPoint(t){
        if (this.quadratic) {
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^2 * this.p1[0] + 2 * (1 - t) * t * this.p2[0] + t^2 * this.p3[0];
                y = (1 - t)^2 * this.p1[1] + 2 * (1 - t) * t * this.p2[1] + t^2 * this.p3[1];
                z = (1 - t)^2 * this.p1[2] + 2 * (1 - t) * t * this.p2[2] + t^2 * this.p3[2];
                return([x,y,z]);
            }
        }
        else { //cubic
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^3 * this.p1[0] + 3 * (1 - t)^2 * t * this.p2[0] + 3 * (1 - t) * t^2 * this.p3[0] + t^3 * this.p4[0];
                y = (1 - t)^3 * this.p1[1] + 3 * (1 - t)^2 * t * this.p2[1] + 3 * (1 - t) * t^2 * this.p3[1] + t^3 * this.p4[1];
                z = (1 - t)^3 * this.p1[2] + 3 * (1 - t)^2 * t * this.p2[2] + 3 * (1 - t) * t^2 * this.p3[2] + t^3 * this.p4[2];
                return([x,y,z]);
            }
        }
    }
    
    fun getPoints(resolution) {
        coordinates = [];
        for(t = 0; t < 1; t = t + resolution){
            coordinates.append(this.getPoint(t));
        }
        return coordinates;
    }
}

class Ellipse {
    var centre;
    var length;
    var width;
    var startingAngle = 0;
    var endAngle = 2 * Math.pi;
    
    var dismantler; 
    var factory = fun(x, y, z) { return [x, y, z]; };

    Ellipse(centre, radius){ //Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
    }
    Ellipse(centre, radius, startingAngle, endAngle){ //Partial Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre, length, width){ //Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
    }
    Ellipse(centre, length, width, startingAngle, endAngle){ //Partial Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre,length,width,startingAngle,endAngle,dismantler,factory){
        this.factory = factory;
        this.dismantler = dismantler;
        this.centre = this.dismantler(centre);
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;     
    }

    fun getPoints(res){
        coordinates = [];
        x = this.centre[0]; y = this.centre[1]; z = this.centre[2];
        resolution = Math.abs((this.endAngle - this.startingAngle))/res;
        for (theta = this.startingAngle; theta < this.endAngle; theta = theta + resolution) {
            l = this.length; w = this.width;
            xOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.cos(theta);
            zOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.sin(theta);
            coordinates.append(this.factory(x + xOffset,y,z + zOffset));
        }
        return coordinates;
    }
}

class PolarCoordinates{
    static fun toPolarCoordinates(x,y){
        angle = Math.arctan(y/x);
        if(x<0){
            angle = angle + Math.pi;
        }
        if(angle.isNaN()){
            angle = 0;
        }
        r = Math.sqrt(x^2+y^2);
        return [angle,r]; 
    }
    static fun toPolarCoordinates(pos){
        angle_1 = Math.arctan(Math.sqrt(pos[0]^2+pos[1]^2)/pos[2]);
        angle_2 = Math.arcsin(pos[1]/pos[0]);
        r = Math.sqrt(pos[0]^2+pos[1]^2+pos[2]^2);
        return [angle_1,angle_2,r];
    }
    static fun toPolarCoordinates(x,y,z){
        angle_1 = Math.arctan(Math.sqrt(x^2+y^2)/z);
        angle_2 = Math.arcsin(y/x);
        r = Math.sqrt(x^2+y^2+z^2);
        return [angle_1,angle_2,r];
    }
    static fun toCartesianCoordinates(angle, r){
        x = r * Math.cos(angle);
        y = r * Math.sin(angle);
        return [x,y];
    }
}

class Transformation {
    var coordinates = [];
    var averageCoordintate = [];

    var dismantler; 
    var factory;
    
    static fun rotate(coordinate, centre, amount,inputAxis) {
        coordinate2D = [];
        axis = ["x","y","z"];
        staticCoordinate = 0;
        i = axis.indexOf(axis);
        foreach(value:coordinate){
            if(axis.indexOf(inputAxis)!=coordinate.indexOf(value)){
                coordinate2D.append(value - centre[coordinate.indexOf(value)]);
            }
            else{
                staticCoordinate = value-centre[axis.indexOf(inputAxis)];
            }
        }
        polarCoordinate = PolarCoordinates.toPolarCoordinates(coordinate2D[0],coordinate2D[1]);
        polarCoordinate[0] = polarCoordinate[0] - amount;
        rotated2DCoordinate = PolarCoordinates.toCartesianCoordinates(polarCoordinate[0],polarCoordinate[1]);
        outputCoordinate = [];
        j=0;
        for(i=0;i<3;i++){
            if(i == axis.indexOf(inputAxis)){
                outputCoordinate.append(staticCoordinate);
            }
            else{
                outputCoordinate.append(rotated2DCoordinate[j]);
                j++;
            }
        }
        return [outputCoordinate[0]+centre[0],outputCoordinate[1]+centre[1],outputCoordinate[2]+centre[2]];
    }


    Transformation(coordinates) {
        this.coordinates = coordinates;
        this.dismantler = fun(vec) { return vec; };
        this.factory = fun(list) { return list; }; 
    }
    Transformation(coordinates,dismantler,factory){
        this.dismantler = dismantler;
        this.factory = factory;
        dismantledCoords = [];
        foreach(coord:coordinates){
            dismantledCoords.append(dismantler(coord));
        }
        this.coordinates = dismantledCoords;
    }

    fun calculateAverageCoordintate(){
        xSum = 0; ySum = 0; zSum = 0;
        foreach (coordinate : this.coordinates) {
            xSum = xSum + coordinate[0];
            ySum = ySum + coordinate[1];
            zSum = zSum + coordinate[2];
        }
        xMean = xSum / len(this.coordinates);
        yMean = ySum / len(this.coordinates);
        zMean = zSum / len(this.coordinates);
        this.averageCoordintate = [xMean, yMean, zMean];
        return  this.factory([xMean, yMean, zMean]);
    }
    fun rotate(amount,axis) {
        this.calculateAverageCoordintate();
        centre = this.averageCoordintate;
        print(Type.of(centre));
        rotatedCoordinates = [];
        returnCoordinates = [];
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
            returnCoordinates.append(this.factory(Transformation.rotate(coordinate,centre,amount,axis)));
        }
        this.coordinates = rotatedCoordinates;
        return returnCoordinates;
    }

    fun rotate(centre, amount,axis){
        rotatedCoordinates = [];
        returnCoordinates = [];
        centre = this.dismantler(centre);
        
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
            returnCoordinates.append(this.factory(Transformation.rotate(coordinate,centre,amount,axis)));
        }
        this.coordinates = rotatedCoordinates;
        return returnCoordinates;
    }

    fun translate(xDistance, yDistance, zDistance) {
        translatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate[0] + xDistance;
            y = coordinate[1] + yDistance;
            z = coordinate[2] + zDistance;
            translatedCoordinates.append([x,y,z]);
            returnCoordinates.append(this.factory([x,y,z]));
        }
        this.coordinates = translatedCoordinates;
        return returnCoordinates;
    }
    
    
    fun reflect(a, b, c) { // ax + bz + c = 0
        reflectedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0] * (a^2 - b^2) - 2 * b * (a * coordinate[2] + c)) / (a^2 + b^2);
            z = (coordinate[2] * (b^2 - a^2) - 2 * a * (b * coordinate[0] + c)) / (a^2 + b^2);
            reflectedCoordinates.append([x, coordinate[1], z]);
            returnCoordinates.append(this.factory([x, coordinate[1], z]));
        }
        this.coordinates = reflectedCoordinates;
        return returnCoordinates;
    }

    //TODO but i'm lazy
    /*
    fun reflect(plane) {
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            if (plane.uppercase() == "XY") {

            }
            else if (plane.uppercase() == "XZ") {

            }
            else if (plane.uppercase() == "YZ") {

            }
        }
        return reflectedCoordinates;
    }
    */

    fun dilate(scale) {
        this.calculateAverageCoordintate();
        origin = this.averageCoordintate;
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * scale;
            y = (coordinate[1]-origin[1]) * scale;
            z = (coordinate[2]-origin[2]) * scale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }

    fun dilate(origin, scale){
        origin = this.dismantler(origin);  
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * scale;
            y = (coordinate[1]-origin[1]) * scale;
            z = (coordinate[2]-origin[2]) * scale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
    fun dilate(origin, xScale, yScale, zScale){
        origin = this.dismantler(origin);
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * xScale;
            y = (coordinate[1]-origin[1]) * yScale;
            z = (coordinate[2]-origin[2]) * zScale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
    fun dilate(xScale, yScale, zScale) {
        this.calculateAverageCoordintate();
        origin = this.averageCoordintate;
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * xScale;
            y = (coordinate[1]-origin[1]) * yScale;
            z = (coordinate[2]-origin[2]) * zScale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
}