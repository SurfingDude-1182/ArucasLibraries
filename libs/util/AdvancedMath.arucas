class PerlinNoise { //TODO: extend Transformation
    var vector_grid = {};
    var vector_grid_2d = {};

    PerlinNoise(){

    }

    fun calculatePerlinValue(pos){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(pos.getX())+i;
            if(!this.vector_grid.getKeys().contains(x))
            this.vector_grid[x]={};
            for(j = 0;j<2;j++){
                y = Math.floor(pos.getY())+j;
                if(!this.vector_grid[x].getKeys().contains(y))
                this.vector_grid[x][y]={};
                for(k = 0;k<2;k++){
                    z =  Math.floor(pos.getZ())+k;
                    if(!this.vector_grid[x][y].getKeys().contains(z)){
                        angle_1 = random(360);
                        angle_2 = random(360);
                        this.vector_grid[x][y][z] = new Pos(Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2)));
                        //this.vector_grid[x][y][z] = new Pos(random(3)-1,random(3)-1,random(3)-1);
                    }
                    vectorList.append(new Pos(x, y, z));
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(j = 0;j<2;j++){
                for(k = 0;k<2;k++){
                    x = Math.floor(pos.getX())+i;
                    y = Math.floor(pos.getY())+j;
                    z = Math.floor(pos.getZ())+k;
                    cornerVector = this.vector_grid[x][y][z];
                    localX = pos.getX()-Math.floor(pos.getX())-i;
                    localY = pos.getY()-Math.floor(pos.getY())-j;
                    localZ = pos.getZ()-Math.floor(pos.getZ())-k;
                    dotProduct = cornerVector.getX()*localX + cornerVector.getY()*localY + cornerVector.getZ()*localZ;
                    dotProductList.append(dotProduct);
                }
            }
        }
        interpolationLevel1 = [];
        for(i=0;i<8;i=i+2){
            weight = pos.getZ()-Math.floor(pos.getZ());
            interpolationLevel1.append(this.interpolate(dotProductList[i],dotProductList[i+1],weight));
        }
        interpolatedNumber1 = this.interpolate(interpolationLevel1[0],interpolationLevel1[1],pos.getY()-Math.floor(pos.getY()));
        interpolatedNumber2 = this.interpolate(interpolationLevel1[2],interpolationLevel1[3],pos.getY()-Math.floor(pos.getY()));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,pos.getX()-Math.floor(pos.getX()));
    }

    //2d noise
    fun calculatePerlinValue(input_x,input_z){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(input_x)+i;
            if(!this.vector_grid_2d.getKeys().contains(x))
            this.vector_grid_2d[x]={};
            for(k = 0;k<2;k++){
                z =  Math.floor(input_z)+k;
                if(!this.vector_grid_2d[x].getKeys().contains(z)){
                    angle_1 = random(360);
                    angle_2 = random(360);
                    //this.vector_grid[x][y][z] = new Pos(Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2)));
                    this.vector_grid_2d[x][z] = new Pos(random(3)-1,0,random(3)-1);
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(k = 0;k<2;k++){
                x = Math.floor(input_x)+i;
                y = 0;
                z = Math.floor(input_z)+k;
                cornerVector = this.vector_grid_2d[x][z];
                localX = input_x-Math.floor(input_x)-i;
                localY = 0;
                localZ = input_z-Math.floor(input_z)-k;
                dotProduct = cornerVector.getX()*localX + cornerVector.getZ()*localZ;
                dotProductList.append(dotProduct);
            }
        }
        
        interpolatedNumber1 = this.interpolate(dotProductList[0],dotProductList[1],input_z-Math.floor(input_z));
        interpolatedNumber2 = this.interpolate(dotProductList[2],dotProductList[3],input_z-Math.floor(input_z));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,input_x-Math.floor(input_x));
    }

    fun interpolate(number1, number2, weight){
        output = number1+this.fadeFunction(weight)*(number2-number1);
        return output;
    }

    fun fadeFunction(number){
        return (6*number^5)-(15*number^4)+(10*number^3);
    }
}

class BezierCurve { //TODO: extend Transformation
    var p1;
    var p2;
    var p3;
    var p4;
    var quadratic = true;
    var coordinates;

    static fun getPoints(posList,resolution){

    }
     
    BezierCurve(posList) {
        this.p1 = posList.get(0);
        this.p2 = posList.get(1);
        this.p3 = posList.get(2);
        if (len(posList) == 4) {
            this.p4 = posList.get(3);
            this.quadratic = false;
        }
        this.coordinates = this.getPoints(100);
    }

    fun getPoint(t){
        if (this.quadratic) {
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^2 * this.p1.getX() + 2 * (1 - t) * t * this.p2.getX() + t^2 * this.p3.getX();
                y = (1 - t)^2 * this.p1.getY() + 2 * (1 - t) * t * this.p2.getY() + t^2 * this.p3.getY();
                z = (1 - t)^2 * this.p1.getZ() + 2 * (1 - t) * t * this.p2.getZ() + t^2 * this.p3.getZ();
                return(new Pos(x,y,z));
            }
        }
        else { //cubic
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^3 * this.p1.getX() + 3 * (1 - t)^2 * t * this.p2.getX() + 3 * (1 - t) * t^2 * this.p3.getX() + t^3 * this.p4.getX();
                y = (1 - t)^3 * this.p1.getY() + 3 * (1 - t)^2 * t * this.p2.getY() + 3 * (1 - t) * t^2 * this.p3.getY() + t^3 * this.p4.getY();
                z = (1 - t)^3 * this.p1.getZ() + 3 * (1 - t)^2 * t * this.p2.getZ() + 3 * (1 - t) * t^2 * this.p3.getZ() + t^3 * this.p4.getZ();
                return(new Pos(x,y,z));
            }
        }
    }
    
    fun getPoints(resolution) {
        coordinates = [];
        for(t = 0; t < 1; t = t + resolution){
            coordinates.append(this.getPoint(t));
        }
        return coordinates;
    }
}

class Ellipse { //TODO: extend Transformation
    var centre;
    var length;
    var width;
    var startingAngle = 0;
    var endAngle = 2 * Math.pi;
    
    Ellipse(centre, radius){ //Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
    }
    Ellipse(centre, radius, startingAngle, endAngle){ //Partial Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre, length, width){ //Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
    }
    Ellipse(centre, length, width, startingAngle, endAngle){ //Partial Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    

    fun getPoints(res){
        coordinates = [];
        x = this.centre.getX(); y = this.centre.getY(); z = this.centre.getZ();
        resolution = Math.abs((this.endAngle - this.startingAngle))/res;
        for (theta = this.startingAngle; theta < this.endAngle; theta = theta + resolution) {
            l = this.length; w = this.width;
            xOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.cos(theta);
            zOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.sin(theta);
            coordinates.append(new Pos(x + xOffset,y,z + zOffset));
        }
        return coordinates;
    }
}

class AdvancedMath{
    static fun toPolarCoordinates(x,y){
        angle = Math.arctan(y/x);
        if(x<0 && y<0){
            angle = angle + 2* Math.pi;
        }
        else if (x>0 && y>0){
            angle = angle;
        }
        else{
            angle = angle + Math.pi;
        }
        r = Math.sqrt(x^2+y^2);
        return [angle,r]; 
    }
    static fun toPolarCoordinates(pos){
        angle_1 = Math.arctan(Math.sqrt(pos.getX()^2+pos.getY()^2)/pos.getZ());
        angle_2 = Math.arcsin(pos.getY()/pos.getX());
        r = Math.sqrt(pos.getX()^2+pos.getY()^2+pos.getZ()^2);
        return new Pos(angle_1,angle_2,r);
    }
    static fun toPolarCoordinates(x,y,z){
        angle_1 = Math.arctan(Math.sqrt(x^2+y^2)/z);
        angle_2 = Math.arcsin(y/x);
        r = Math.sqrt(x^2+y^2+z^2);
        return [angle_1,angle_2,r];
    }
    static fun toCartesianCoordinates(angle, r){
        x = r * Math.cos(angle);
        y = r * Math.sin(angle);
        return [x,y];
    }
}

class Transformation {
    var coordinates = [];

    static fun rotate(coordinate, centre, amount,inputAxis) {
        coordinate2D = [];
        axis = ["x","y","z"];
        staticCoordinate = 0;
        i = axis.indexOf(axis);
        foreach(value:coordinate.toList()){
            if(axis.indexOf(inputAxis)!=coordinate.toList().indexOf(value)){
                coordinate2D.append(value - centre.toList()[coordinate.toList().indexOf(value)]);
            }
            else{
                staticCoordinate = value-centre.toList()[axis.indexOf(inputAxis)];
            }
        }
        polarCoordinate = AdvancedMath.toPolarCoordinates(coordinate2D[0],coordinate2D[1]);
        polarCoordinate[0] = polarCoordinate[0] + amount;
        rotated2DCoordinate = AdvancedMath.toCartesianCoordinates(polarCoordinate[0],polarCoordinate[1]);
        outputCoordinate = [];
        j=0;
        for(i=0;i<3;i++){
            if(i == axis.indexOf(inputAxis)){
                outputCoordinate.append(staticCoordinate);
            }
            else{
                outputCoordinate.append(rotated2DCoordinate[j]);
                j++;
            }
        }
        return new Pos(outputCoordinate[0],outputCoordinate[1],outputCoordinate[2]).add(centre);
    }


    Transformation(coordinates) {
        this.coordinates = coordinates;
    }
    fun rotate(amount,axis) {
        xSum = 0; ySum = 0; zSum = 0;
        foreach (coordinate : this.coordinates) {
            xSum = xSum + coordinate.getX();
            ySum = ySum + coordinate.getY();
            zSum = zSum + coordinate.getZ();
        }
        xMean = xSum / len(this.coordinates);
        yMean = ySum / len(this.coordinates);
        zMean = zSum / len(this.coordinates);
        centre = new Pos(xMean, yMean, zMean);
        rotatedCoordinates = [];
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
        }
        this.coordinates = rotatedCoordinates;
        return rotatedCoordinates;
    }

    fun rotate(centre, amount,axis){
        rotatedCoordinates = [];
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
        }
        this.coordinates = rotatedCoordinates;
        return rotatedCoordinates;
    }

    fun translate(xDistance, yDistance, zDistance) {
        translatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() + xDistance;
            y = coordinate.getY() + yDistance;
            z = coordinate.getZ() + zDistance;
            translatedCoordinates.append(new Pos(x,y,z));
        }
        this.coordinates = translatedCoordinates;
        return translatedCoordinates;
    }
    
    
    fun reflect(a, b, c) { // ax + bz + c = 0
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate.getX() * (a^2 - b^2) - 2 * b * (a * coordinate.getZ() + c)) / (a^2 + b^2);
            z = (coordinate.getZ() * (b^2 - a^2) - 2 * a * (b * coordinate.getX() + c)) / (a^2 + b^2);
            reflectedCoordinates.append(new Pos(x, coordinate.getY(), z));
        }
        this.coordinates = reflectedCoordinates;
        return reflectedCoordinates;
    }

    //TODO but i'm lazy
    /*
    fun reflect(plane) {
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            if (plane.uppercase() == "XY") {

            }
            else if (plane.uppercase() == "XZ") {

            }
            else if (plane.uppercase() == "YZ") {

            }
        }
        return reflectedCoordinates;
    }
    */

    fun dilate(scale) {
        dilatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() * scale;
            y = coordinate.getY() * scale;
            z = coordinate.getZ() * scale;
            dilatedCoordinates.append(new Pos(x,y,z));
        }
        this.coordinates = dilatedCoordinates;
        return dilatedCoordinates;
    }

    fun dilate(xScale, yScale, zScale) {
        dilatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() * xScale;
            y = coordinate.getY() * yScale;
            z = coordinate.getZ() * zScale;
            dilatedCoordinates.append(new Pos(x,y,z));
        }
        this.coordinates = dilatedCoordinates;
        return dilatedCoordinates;
    }
}
