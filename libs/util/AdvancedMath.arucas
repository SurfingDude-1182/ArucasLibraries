class PerlinNoise { //TODO: extend Transformation
    var vector_grid = {};
    var vector_grid_2d = {};
    var dismantler;

    PerlinNoise(){
        this.dismantler = fun(vec) { return vec; }; 
    }

    PerlinNoise(dismantler){
        this.dismantler = dismantler;
    }

    fun calculatePerlinValue(pos){
        pos = this.dismantler(pos);
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(pos[0])+i;
            if(!this.vector_grid.getKeys().contains(x))
            this.vector_grid[x]={};
            for(j = 0;j<2;j++){
                y = Math.floor(pos[1])+j;
                if(!this.vector_grid[x].getKeys().contains(y))
                this.vector_grid[x][y]={};
                for(k = 0;k<2;k++){
                    z =  Math.floor(pos[2])+k;
                    if(!this.vector_grid[x][y].getKeys().contains(z)){
                        angle_1 = random(360);
                        angle_2 = random(360);
                        this.vector_grid[x][y][z] = [Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2))];
                        //this.vector_grid[x][y][z] = [random(3)-1,random(3)-1,random(3)-1)];
                    }
                    vectorList.append([x, y, z]);
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(j = 0;j<2;j++){
                for(k = 0;k<2;k++){
                    x = Math.floor(pos[0])+i;
                    y = Math.floor(pos[1])+j;
                    z = Math.floor(pos[2])+k;
                    cornerVector = this.vector_grid[x][y][z];
                    localX = pos[0]-Math.floor(pos[0])-i;
                    localY = pos[1]-Math.floor(pos[1])-j;
                    localZ = pos[2]-Math.floor(pos[2])-k;
                    dotProduct = cornerVector[0]*localX + cornerVector[1]*localY + cornerVector[2]*localZ;
                    dotProductList.append(dotProduct);
                }
            }
        }
        interpolationLevel1 = [];
        for(i=0;i<8;i=i+2){
            weight = pos[2]-Math.floor(pos[2]);
            interpolationLevel1.append(this.interpolate(dotProductList[i],dotProductList[i+1],weight));
        }
        interpolatedNumber1 = this.interpolate(interpolationLevel1[0],interpolationLevel1[1],pos[1]-Math.floor(pos[1]));
        interpolatedNumber2 = this.interpolate(interpolationLevel1[2],interpolationLevel1[3],pos[1]-Math.floor(pos[1]));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,pos[0]-Math.floor(pos[0]));
    }

    //2d noise
    fun calculatePerlinValue(input_x,input_z){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(input_x)+i;
            if(!this.vector_grid_2d.getKeys().contains(x))
            this.vector_grid_2d[x]={};
            for(k = 0;k<2;k++){
                z =  Math.floor(input_z)+k;
                if(!this.vector_grid_2d[x].getKeys().contains(z)){
                    angle_1 = random(360);
                    angle_2 = random(360);
                    //this.vector_grid[x][y][z] = [Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2))];
                    this.vector_grid_2d[x][z] = [random(3)-1,0,random(3)-1];
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(k = 0;k<2;k++){
                x = Math.floor(input_x)+i;
                y = 0;
                z = Math.floor(input_z)+k;
                cornerVector = this.vector_grid_2d[x][z];
                localX = input_x-Math.floor(input_x)-i;
                localY = 0;
                localZ = input_z-Math.floor(input_z)-k;
                dotProduct = cornerVector[0]*localX + cornerVector[2]*localZ;
                dotProductList.append(dotProduct);
            }
        }
        
        interpolatedNumber1 = this.interpolate(dotProductList[0],dotProductList[1],input_z-Math.floor(input_z));
        interpolatedNumber2 = this.interpolate(dotProductList[2],dotProductList[3],input_z-Math.floor(input_z));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,input_x-Math.floor(input_x));
    }

    fun interpolate(number1, number2, weight){
        output = number1+this.fadeFunction(weight)*(number2-number1);
        return output;
    }

    fun fadeFunction(number){
        return (6*number^5)-(15*number^4)+(10*number^3);
    }
}

class BezierCurve { //TODO: extend Transformation
    var p1;
    var p2;
    var p3;
    var p4;
    var quadratic = true;
    var coordinates;

    var dismantler = fun(vec) { return vec; }; 
    var factory = fun(x, y, z) { return [x, y, z]; };

    static fun getPoints(posList,resolution){
        quadratic = true;
        p1 = posList.get(0);
        p2 = posList.get(1);
        p3 = posList.get(2);
        coordinates = [];
        if (len(posList) == 4) {
            p4 = posList.get(3);
            quadratic = false;
        }
        for(t = 0; t < 1; t = t + resolution){
            if (this.quadratic) {
                for (t = 0; t < 1; t = t + (1/resolution)) {
                    x = (1 - t)^2 * this.p1[0] + 2 * (1 - t) * t * this.p2[0] + t^2 * this.p3[0];
                    y = (1 - t)^2 * this.p1[1] + 2 * (1 - t) * t * this.p2[1] + t^2 * this.p3[1];
                    z = (1 - t)^2 * this.p1[2] + 2 * (1 - t) * t * this.p2[2] + t^2 * this.p3[2];
                    coordinates.append([x,y,z]);
                }
            }
            else { //cubic
                for (t = 0; t < 1; t = t + (1/resolution)) {
                    x = (1 - t)^3 * this.p1[0] + 3 * (1 - t)^2 * t * this.p2[0] + 3 * (1 - t) * t^2 * this.p3[0] + t^3 * this.p4[0];
                    y = (1 - t)^3 * this.p1[1] + 3 * (1 - t)^2 * t * this.p2[1] + 3 * (1 - t) * t^2 * this.p3[1] + t^3 * this.p4[1];
                    z = (1 - t)^3 * this.p1[2] + 3 * (1 - t)^2 * t * this.p2[2] + 3 * (1 - t) * t^2 * this.p3[2] + t^3 * this.p4[2];
                    coordinates.append([x,y,z]);
                }
            }
        }
    }
     
    BezierCurve(posList) {
        this.p1 = posList.get(0);
        this.p2 = posList.get(1);
        this.p3 = posList.get(2);
        if (len(posList) == 4) {
            this.p4 = posList.get(3);
            this.quadratic = false;
        }
        this.coordinates = this.getPoints(100);
    }

    fun getPoint(t){
        if (this.quadratic) {
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^2 * this.p1[0] + 2 * (1 - t) * t * this.p2[0] + t^2 * this.p3[0];
                y = (1 - t)^2 * this.p1[1] + 2 * (1 - t) * t * this.p2[1] + t^2 * this.p3[1];
                z = (1 - t)^2 * this.p1[2] + 2 * (1 - t) * t * this.p2[2] + t^2 * this.p3[2];
                return([x,y,z]);
            }
        }
        else { //cubic
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^3 * this.p1[0] + 3 * (1 - t)^2 * t * this.p2[0] + 3 * (1 - t) * t^2 * this.p3[0] + t^3 * this.p4[0];
                y = (1 - t)^3 * this.p1[1] + 3 * (1 - t)^2 * t * this.p2[1] + 3 * (1 - t) * t^2 * this.p3[1] + t^3 * this.p4[1];
                z = (1 - t)^3 * this.p1[2] + 3 * (1 - t)^2 * t * this.p2[2] + 3 * (1 - t) * t^2 * this.p3[2] + t^3 * this.p4[2];
                return([x,y,z]);
            }
        }
    }
    
    fun getPoints(resolution) {
        coordinates = [];
        for(t = 0; t < 1; t = t + resolution){
            coordinates.append(this.getPoint(t));
        }
        return coordinates;
    }
}

class Ellipse {
    var centre;
    var length;
    var width;
    var startingAngle = 0;
    var endAngle = 2 * Math.pi;
    
    var dismantler; 
    var factory = fun(x, y, z) { return [x, y, z]; };

    Ellipse(centre, radius){ //Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
    }
    Ellipse(centre, radius, startingAngle, endAngle){ //Partial Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre, length, width){ //Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
    }
    Ellipse(centre, length, width, startingAngle, endAngle){ //Partial Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre,length,width,startingAngle,endAngle,dismantler,factory){
        this.factory = factory;
        this.dismantler = dismantler;
        this.centre = this.dismantler(centre);
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;     
    }

    fun getPoints(res){
        coordinates = [];
        x = this.centre[0]; y = this.centre[1]; z = this.centre[2];
        resolution = Math.abs((this.endAngle - this.startingAngle))/res;
        for (theta = this.startingAngle; theta < this.endAngle; theta = theta + resolution) {
            l = this.length; w = this.width;
            xOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.cos(theta);
            zOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.sin(theta);
            coordinates.append(this.factory(x + xOffset,y,z + zOffset));
        }
        return coordinates;
    }
}

class PolarCoordinates{
    static fun toPolarCoordinates(x,y){
        angle = Math.arctan(y/x);
        if(x<0){
            angle = angle + Math.pi;
        }
        if(angle.isNaN()){
            angle = 0;
        }
        r = Math.sqrt(x^2+y^2);
        return [angle,r]; 
    }
    static fun toPolarCoordinates(pos){
        angle_1 = Math.arctan(Math.sqrt(pos[0]^2+pos[1]^2)/pos[2]);
        angle_2 = Math.arcsin(pos[1]/pos[0]);
        r = Math.sqrt(pos[0]^2+pos[1]^2+pos[2]^2);
        return [angle_1,angle_2,r];
    }
    static fun toPolarCoordinates(x,y,z){
        angle_1 = Math.arctan(Math.sqrt(x^2+y^2)/z);
        angle_2 = Math.arcsin(y/x);
        r = Math.sqrt(x^2+y^2+z^2);
        return [angle_1,angle_2,r];
    }
    static fun toCartesianCoordinates(angle, r){
        x = r * Math.cos(angle);
        y = r * Math.sin(angle);
        return [x,y];
    }
}

class Transformation {
    var coordinates = [];
    var averageCoordintate = [];

    var dismantler; 
    var factory;
    
    static fun rotate(coordinate, centre, amount,inputAxis) {
        coordinate2D = [];
        axis = ["x","y","z"];
        staticCoordinate = 0;
        i = axis.indexOf(axis);
        foreach(value:coordinate){
            if(axis.indexOf(inputAxis)!=coordinate.indexOf(value)){
                coordinate2D.append(value - centre[coordinate.indexOf(value)]);
            }
            else{
                staticCoordinate = value-centre[axis.indexOf(inputAxis)];
            }
        }
        polarCoordinate = PolarCoordinates.toPolarCoordinates(coordinate2D[0],coordinate2D[1]);
        polarCoordinate[0] = polarCoordinate[0] - amount;
        rotated2DCoordinate = PolarCoordinates.toCartesianCoordinates(polarCoordinate[0],polarCoordinate[1]);
        outputCoordinate = [];
        j=0;
        for(i=0;i<3;i++){
            if(i == axis.indexOf(inputAxis)){
                outputCoordinate.append(staticCoordinate);
            }
            else{
                outputCoordinate.append(rotated2DCoordinate[j]);
                j++;
            }
        }
        return [outputCoordinate[0]+centre[0],outputCoordinate[1]+centre[1],outputCoordinate[2]+centre[2]];
    }


    Transformation(coordinates) {
        this.coordinates = coordinates;
        this.dismantler = fun(vec) { return vec; };
        this.factory = fun(list) { return list; }; 
    }
    Transformation(coordinates,dismantler,factory){
        this.dismantler = dismantler;
        this.factory = factory;
        dismantledCoords = [];
        foreach(coord:coordinates){
            dismantledCoords.append(dismantler(coord));
        }
        this.coordinates = dismantledCoords;
    }

    fun calculateAverageCoordintate(){
        xSum = 0; ySum = 0; zSum = 0;
        foreach (coordinate : this.coordinates) {
            xSum = xSum + coordinate[0];
            ySum = ySum + coordinate[1];
            zSum = zSum + coordinate[2];
        }
        xMean = xSum / len(this.coordinates);
        yMean = ySum / len(this.coordinates);
        zMean = zSum / len(this.coordinates);
        this.averageCoordintate = [xMean, yMean, zMean];
        return  this.factory([xMean, yMean, zMean]);
    }
    fun rotate(amount,axis) {
        this.calculateAverageCoordintate();
        centre = this.averageCoordintate;
        print(Type.of(centre));
        rotatedCoordinates = [];
        returnCoordinates = [];
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
            returnCoordinates.append(this.factory(Transformation.rotate(coordinate,centre,amount,axis)));
        }
        this.coordinates = rotatedCoordinates;
        return returnCoordinates;
    }

    fun rotate(centre, amount,axis){
        rotatedCoordinates = [];
        returnCoordinates = [];
        centre = this.dismantler(centre);
        
        foreach(coordinate:this.coordinates){
            rotatedCoordinates.append(Transformation.rotate(coordinate,centre,amount,axis));
            returnCoordinates.append(this.factory(Transformation.rotate(coordinate,centre,amount,axis)));
        }
        this.coordinates = rotatedCoordinates;
        return returnCoordinates;
    }

    fun translate(xDistance, yDistance, zDistance) {
        translatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate[0] + xDistance;
            y = coordinate[1] + yDistance;
            z = coordinate[2] + zDistance;
            translatedCoordinates.append([x,y,z]);
            returnCoordinates.append(this.factory([x,y,z]));
        }
        this.coordinates = translatedCoordinates;
        return returnCoordinates;
    }
    
    
    fun reflect(a, b, c) { // ax + bz + c = 0
        reflectedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0] * (a^2 - b^2) - 2 * b * (a * coordinate[2] + c)) / (a^2 + b^2);
            z = (coordinate[2] * (b^2 - a^2) - 2 * a * (b * coordinate[0] + c)) / (a^2 + b^2);
            reflectedCoordinates.append([x, coordinate[1], z]);
            returnCoordinates.append(this.factory([x, coordinate[1], z]));
        }
        this.coordinates = reflectedCoordinates;
        return returnCoordinates;
    }

    //TODO but i'm lazy
    /*
    fun reflect(plane) {
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            if (plane.uppercase() == "XY") {

            }
            else if (plane.uppercase() == "XZ") {

            }
            else if (plane.uppercase() == "YZ") {

            }
        }
        return reflectedCoordinates;
    }
    */

    fun dilate(scale) {
        this.calculateAverageCoordintate();
        origin = this.averageCoordintate;
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * scale;
            y = (coordinate[1]-origin[1]) * scale;
            z = (coordinate[2]-origin[2]) * scale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }

    fun dilate(origin, scale){
        origin = this.dismantler(origin);  
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * scale;
            y = (coordinate[1]-origin[1]) * scale;
            z = (coordinate[2]-origin[2]) * scale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
    fun dilate(origin, xScale, yScale, zScale){
        origin = this.dismantler(origin);
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * xScale;
            y = (coordinate[1]-origin[1]) * yScale;
            z = (coordinate[2]-origin[2]) * zScale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
    fun dilate(xScale, yScale, zScale) {
        this.calculateAverageCoordintate();
        origin = this.averageCoordintate;
        dilatedCoordinates = [];
        returnCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate[0]-origin[0]) * xScale;
            y = (coordinate[1]-origin[1]) * yScale;
            z = (coordinate[2]-origin[2]) * zScale;
            dilatedCoordinates.append([x+origin[0],y+origin[1],z+origin[2]]);
            returnCoordinates.append(this.factory([x+origin[0],y+origin[1],z+origin[2]]));
        }
        this.coordinates = dilatedCoordinates;
        return returnCoordinates;
    }
}

class Graph{
    static fun evaluate(function, fnDomain, resolution) { //TODO: multiple parameters for domain/range and inclusive/exculsive specification
        values = [];
        for (x = fnDomain[0]; x < fnDomain[1] x = x + ((fnDomain[1]-fnDomain[0]) / resolution)) {
            y = function(x);
            values.append(y);
        }
        return values;
    }
}

class ComplexNumber{
    var number = [];

    ComplexNumber(a,b){
        this.a;
        this.b;
    }
    operator + (other){
        if(Type.of(other).getName()=="Number"){
            return [this.number[0] + other,this.number[1]];
        }
        else{
            return [this.number[0] + other.number[0], this.number[1]+other.number[1]];
        }
    }
    operator - (other){
        if(Type.of(other).getName()=="Number"){
            return [this.number[0] - other,this.number[1]];
        }
        else{
            return [this.number[0] - other.number[0], this.number[1]-other.number[1]];
        }
    }
    operator * (other){
        if(Type.of(other).getName()=="Number"){
            return [this.number[0] * other,this.number[1]*other];
        }
        else{
            a1, a2 = this.number;
            b1, b2 = this.other;
            z1 = (a1*a2-b1*b2);
            z2 = (a1*b2-a2*b1);
            return [z1,z2];
        }
    }   
    operator / (other){
        if(Type.of(other).getName()=="Number"){
            return [this.number[0]/other,this.number[1]/other];
        }
        else{
            a1, a2 = this.number;
            b1, b2 = this.other;
            z1 = (a1*a2+b1*b2)/(a2^2+b2^2);
            z2 = (a2*b1-a1*b2)/(a2^2+b2^2);
            return [z1,z2];
        }
    }
    fun getExponentialForm(){
        r = sqrt(a^2+b^2);
        theta = Math.arctan(Math.abs(b)/Math.abs(a));
        return(r,theta);
    }
    
}

class Vec2d {
    var x;
    var y;
    
    Vec2d(x: Number,y: Number) {
        this.x = x;
        this.y = y;
    }

    static fun zeroVector(): Vec2d {
        return new Vec2d(0, 0);
    }

    static fun fromScalar(s: Number): Vec2d {
        return new Vec2d(s, s);
    }

    /**
     * -pi to pi
     */
    static fun angleBetween(v1: Vec2d, v2: Vec2d): Number {
        // -2pi to 2pi
        angleBetween = v1.angle() - v2.angle();
        if (angleBetween > Math.pi) {
            angleBetween = angleBetween - 2 * Math.pi;
        } else if (angleBetween <= -Math.pi) {
            angleBetween = angleBetween + 2 * Math.pi;
        }
        return angleBetween;
    }

    /**
     * Tests whether a point lies to the left of a line
     * @param  {Vec2d} linePoint     Point on the line
     * @param  {Vec2d} lineDirection 
     * @param  {Vec2d} point
     * @return {Vec2d}               true if left, false otherwise
     */
    static fun isLeft(linePoint: Vec2d, lineDirection: Vec2d, point: Vec2d): Boolean {
        perpendicularVector = new Vec2d(lineDirection.y, -lineDirection.x);
        return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
    }

    fun add(v: Vec2d): Vec2d {
        x = this.x + v.x;
        y = this.y + v.y;
        return new Vec2d(x,y);
    }

    /**
     * Angle in radians to positive x-axis between -pi and pi
     */
    fun angle(): Number {
        return Math.arctan(this.y/this.x);
    }

    fun clone(): Vec2d {
        return new Vec2d(this.x, this.y);
    }

    fun copy(v: Vec2d): Vec2d {
        x = v.x;
        y = v.y;
        return new Vec2d(x,y);
    }

    fun cross(v: Vec2d): Number {
        return this.x * v.y - this.y * v.x;
    }

    fun distanceTo(v: Vec2d): Number {
        return Math.sqrt(this.distanceToSquared(v));
    }

    fun distanceToSquared (v: Vec2d): Number {
        dx = this.x - v.x;
        dy = this.y - v.y;
        return dx * dx + dy * dy;
    }

    fun divide(v: Vec2d): Vec2d {
        if (v.x == 0 || v.y == 0) {
            return this.copy();
        }

        x = this.x/v.x;
        y = this.y/v.y;
        return new Vec2d(x,y);
    }

    fun divideScalar(s: Number): Vec2d {
        if (s == 0) {
            return this;
        }
        return this.multiplyScalar(1 / s);
    }

    fun dot(v: Vec2d): Number {
        return this.x * v.x + this.y * v.y;
    }

    fun equals(v: Vec2d): Boolean {
        return ((v.x == this.x) && (v.y == this.y));
    }

    fun length(): Number {
        return Math.sqrt(this.lengthSq());
    }

    fun lengthSq(): Number {
        return this.x * this.x + this.y * this.y;
    }

    fun multiply(v: Vec2d): Vec2d {
        x = this.x * v.x;
        y = this.y * v.y;
        return new Vec2d(x,y);
    }

    fun multiplyScalar(s: Number): Vec2d {
        x = this.x * s;
        y = this.y * s;
        return new Vec2d(x,y);
    }

    fun negate(): Vec2d {
        return this.multiplyScalar(-1);
    }

    fun normalize(): Vec2d {
        l = this.length();
        if (l == 0) {
            return this.copy();
        }
        
        return this.divideScalar(this.length());
    }

    /**
     * Angle in radians
     */
    fun rotateAround(center: Vec2d, angle: Number): Vec2d {
        cos = Math.cos(angle);
        sin = Math.sin(angle);

        x = this.x - center.x;
        y = this.y - center.y;

        x = x * cos - y * sin + center.x;
        y = x * sin + y * cos + center.y;
        return new Vec2d(x,y);
    }

    fun set(v: Vec2d): Vec2d {
        this.x = v.x;
        this.y = v.y;
        return this;
    }

    fun setX(x: Number): Vec2d {
        this.x = x;
        return this;
    }

    fun setY(y: Number): Vec2d {
        this.y = y;
        return this;
    }

    fun setLength (length: Number): Vec2d {
        return this.normalize().multiplyScalar(length);
    }

    fun sub(v: Vec2d): Vec2d {
        x = this.x - v.x;
        y = this.y - v.y;
        return new Vec2d(x,y);
    }
}