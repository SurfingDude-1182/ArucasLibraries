class PerlinNoise {
    var vector_grid = {};
    var vector_grid_2d = {};

    PerlinNoise(){

    }

    fun calculatePerlinValue(pos){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(pos.getX())+i;
            if(!this.vector_grid.getKeys().contains(x))
            this.vector_grid[x]={};
            for(j = 0;j<2;j++){
                y = Math.floor(pos.getY())+j;
                if(!this.vector_grid[x].getKeys().contains(y))
                this.vector_grid[x][y]={};
                for(k = 0;k<2;k++){
                    z =  Math.floor(pos.getZ())+k;
                    if(!this.vector_grid[x][y].getKeys().contains(z)){
                        angle_1 = random(360);
                        angle_2 = random(360);
                        this.vector_grid[x][y][z] = new Pos(Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2)));
                        //this.vector_grid[x][y][z] = new Pos(random(3)-1,random(3)-1,random(3)-1);
                    }
                    vectorList.append(new Pos(x, y, z));
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(j = 0;j<2;j++){
                for(k = 0;k<2;k++){
                    x = Math.floor(pos.getX())+i;
                    y = Math.floor(pos.getY())+j;
                    z = Math.floor(pos.getZ())+k;
                    cornerVector = this.vector_grid[x][y][z];
                    localX = pos.getX()-Math.floor(pos.getX())-i;
                    localY = pos.getY()-Math.floor(pos.getY())-j;
                    localZ = pos.getZ()-Math.floor(pos.getZ())-k;
                    dotProduct = cornerVector.getX()*localX + cornerVector.getY()*localY + cornerVector.getZ()*localZ;
                    dotProductList.append(dotProduct);
                }
            }
        }
        interpolationLevel1 = [];
        for(i=0;i<8;i=i+2){
            weight = pos.getZ()-Math.floor(pos.getZ());
            interpolationLevel1.append(this.interpolate(dotProductList[i],dotProductList[i+1],weight));
        }
        interpolatedNumber1 = this.interpolate(interpolationLevel1[0],interpolationLevel1[1],pos.getY()-Math.floor(pos.getY()));
        interpolatedNumber2 = this.interpolate(interpolationLevel1[2],interpolationLevel1[3],pos.getY()-Math.floor(pos.getY()));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,pos.getX()-Math.floor(pos.getX()));
    }

    //2d noise
    fun calculatePerlinValue(input_x,input_z){
        vectorList = [];
        for(i = 0;i<2;i++){
            x = Math.floor(input_x)+i;
            if(!this.vector_grid_2d.getKeys().contains(x))
            this.vector_grid_2d[x]={};
            for(k = 0;k<2;k++){
                z =  Math.floor(input_z)+k;
                if(!this.vector_grid_2d[x].getKeys().contains(z)){
                    angle_1 = random(360);
                    angle_2 = random(360);
                    //this.vector_grid[x][y][z] = new Pos(Math.cos(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_1)),Math.sin(Math.toRadians(angle_2)));
                    this.vector_grid_2d[x][z] = new Pos(random(3)-1,0,random(3)-1);
                }
            }
        }
        dotProductList = [];
        for(i = 0;i<2;i++){
            for(k = 0;k<2;k++){
                x = Math.floor(input_x)+i;
                y = 0;
                z = Math.floor(input_z)+k;
                cornerVector = this.vector_grid_2d[x][z];
                localX = input_x-Math.floor(input_x)-i;
                localY = 0;
                localZ = input_z-Math.floor(input_z)-k;
                dotProduct = cornerVector.getX()*localX + cornerVector.getZ()*localZ;
                dotProductList.append(dotProduct);
            }
        }
        
        interpolatedNumber1 = this.interpolate(dotProductList[0],dotProductList[1],input_z-Math.floor(input_z));
        interpolatedNumber2 = this.interpolate(dotProductList[2],dotProductList[3],input_z-Math.floor(input_z));
        return this.interpolate(interpolatedNumber1,interpolatedNumber2,input_x-Math.floor(input_x));
    }

    fun interpolate(number1, number2, weight){
        output = number1+this.fadeFunction(weight)*(number2-number1);
        return output;
    }

    fun fadeFunction(number){
        return (6*number^5)-(15*number^4)+(10*number^3);
    }
}

class BezierCurve {
    var p1;
    var p2;
    var p3;
    var p4;
    var quadratic = true;
    var coordinates;

    BezierCurve(posList) {
        this.p1 = posList.get(0);
        this.p2 = posList.get(1);
        this.p3 = posList.get(2);
        if (len(posList) == 4) {
            this.p4 = posList.get(3);
            this.quadratic = false;
        }
        this.coordinates = this.getPoints(100);
    }

    fun getPoint(t){
        if (this.quadratic) {
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^2 * this.p1.getX() + 2 * (1 - t) * t * this.p2.getX() + t^2 * this.p3.getX();
                y = (1 - t)^2 * this.p1.getY() + 2 * (1 - t) * t * this.p2.getY() + t^2 * this.p3.getY();
                z = (1 - t)^2 * this.p1.getZ() + 2 * (1 - t) * t * this.p2.getZ() + t^2 * this.p3.getZ();
                return(new Pos(x,y,z));
            }
        }
        else { //cubic
            for (t = 0; t < 1; t = t + (1/resolution)) {
                x = (1 - t)^3 * this.p1.getX() + 3 * (1 - t)^2 * t * this.p2.getX() + 3 * (1 - t) * t^2 * this.p3.getX() + t^3 * this.p4.getX();
                y = (1 - t)^3 * this.p1.getY() + 3 * (1 - t)^2 * t * this.p2.getY() + 3 * (1 - t) * t^2 * this.p3.getY() + t^3 * this.p4.getY();
                z = (1 - t)^3 * this.p1.getZ() + 3 * (1 - t)^2 * t * this.p2.getZ() + 3 * (1 - t) * t^2 * this.p3.getZ() + t^3 * this.p4.getZ();
                return(new Pos(x,y,z));
            }
        }
    }
    
    fun getPoints(resolution) {
        coordinates = [];
        for(t = 0; t < 1; t = t + resolution){
            coordinates.append(this.getPoint(t));
        }
        return coordinates;
    }
}

class Ellipse {
    var centre;
    var length;
    var width;
    var startingAngle = 0;
    var endAngle = 2 * Math.pi;
    
    Ellipse(centre, radius){ //Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
    }
    Ellipse(centre, radius, startingAngle, endAngle){ //Partial Circle
        this.centre = centre;
        this.length = radius;
        this.width = radius;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    Ellipse(centre, length, width){ //Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
    }
    Ellipse(centre, length, width, startingAngle, endAngle){ //Partial Ellipse
        this.centre = centre;
        this.length = length;
        this.width = width;
        this.startingAngle = startingAngle;
        this.endAngle = endAngle;
    }
    

    fun getPoints(res){
        coordinates = [];
        x = this.centre.getX(); y = this.centre.getY(); z = this.centre.getZ();
        resolution = Math.abs((this.endAngle - this.startingAngle))/res;
        for (theta = this.startingAngle; theta < this.endAngle; theta = theta + resolution) {
            l = this.length; w = this.width;
            xOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.cos(theta);
            zOffset = (0.25 * l * w) / (Math.sqrt((0.5 * w * Math.sin(theta)) ^ 2 + (0.5 * l * Math.cos(theta)) ^ 2)) * Math.sin(theta);
            coordinates.append(new Pos(x + xOffset,y,z + zOffset));
        }
        return coordinates;
    }
}

class Transformation {
    var coordinates;

    Transformation(coordinates) {
        this.coordinates = coordinates;
    }

    fun rotate(amount, unit) {
        foreach (coordinate : this.coordinates) {
            xSum = 0; ySum = 0; zSum = 0;
            xSum += coordinate.getX();
            ySum += coordinate.getY();
            zSum += coordinate.getZ();
        }
        xMean = xSum / len(this.coordinates);
        yMean = ySum / len(this.coordinates);
        zMean = zSum / len(this.coordinates);
        centre = new Pos(xMean, yMean, zMean);
 
        this.rotate(centre, amount, unit);
    }

    fun rotate(centre, amount, unit) {
        rotatedCoordinates = [];

        return rotatedCoordinates;
    }

    fun translate(xDistance, yDistance, zDistance) {
        translatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() + xDistance;
            y = coordinate.getY() + yDistance;
            z = coordinate.getZ() + zDistance;
            translatedCoordinates.append(new Pos(x,y,z));
        }
        return translatedCoordinates;
    }
    
    //TODO: 3D
    fun reflect(a, b, c) { // ax + bz + c = 0
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = (coordinate.getX() * (a^2 - b^2) - 2 * b * (a * coordinate.getZ() + c)) / (a^2 + b^2);
            z = (coordinate.getZ() * (b^2 - a^2) - 2 * a * (b * coordinate.getX() + c)) / (a^2 + b^2);
            reflectedCoordinates.append(new Pos(x, coordinate.getY(), z);
        }
        return reflectedCoordinates;
    }

    fun reflect(axis) {
        reflectedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            if (axis.uppercase() == "X") {

            }
            else if (axis.uppercase() == "Y") {

            }
            else if (axis.uppercase() == "Z") {

            }
        }
        return reflectedCoordinates;
    }

    fun dilate(scale) {
        dilatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() * scale;
            y = coordinate.getY() * scale;
            z = coordinate.getZ() * scale;
            dilatedCoordinates.append(new Pos(x,y,z));
        }
        return dilatedCoordinates;
    }

    fun dilate(xScale, yScale, zScale) {
        dilatedCoordinates = [];
        foreach (coordinate : this.coordinates) {
            x = coordinate.getX() * xScale;
            y = coordinate.getY() * yScale;
            z = coordinate.getZ() * zScale;
            dilatedCoordinates.append(new Pos(x,y,z));
        }
        return dilatedCoordinates;
    }
}
